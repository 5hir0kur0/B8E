package assembler;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;

/**
 * @author Noxgrim
 */
public class Assembled {

    /** Whether this Assembled has unresolved labels. */
    private boolean unresolved;
    /** Whether this Assembled is sensitive to its position in the code memory. */
    private boolean positionSensitive;

    /** Tokens used to Assemble this assembled. */
    private List<Token> tokens;
    /** The position of the opcode in the code memory. */
    private long codePoint;
    /** The codes produced after assembling. */
    private byte[] codes;

    /** The reserved length. */
    private int length;

    /** The mnemonic used for this Assembled for quicker access. */
    private Mnemonic mnemonic;


    /**
     * Constructs a new Assembled object that is produced by the assembler.
     *
     * @param tokens
     *      The tokens used for this Assembled object.
     * @param codePoint
     *      The position of the opcode in the code memory.
     * @param mnemonic
     *      The mnemonic used for assembling.
     */
    public Assembled(long codePoint, List<Token> tokens, Mnemonic mnemonic) {
        this(false, mnemonic.isPositionSensitive(), tokens, codePoint, new byte[0], 0, mnemonic);
    }
    /**
     * Constructs a new Assembled object that is produced by the assembler.
     *
     * @param unresolved
     *      Indicates that this assembled is still unresolved.<br>
     *      This means that some Labels could not resolved into the corresponding
     *      addresses because they haven't been 'found' yet.
     * @param positionSensitive
     *      Indicates whether the used Mnemonic is position relative.<br>
     *      A Mnemonic is position relative if the resulting codes change if
     *      the code point changes.
     * @param tokens
     *      The tokens used for this Assembled object.
     * @param codePoint
     *      The position of the opcode in the code memory.
     * @param codes
     *      The codes generated by by the Mnemonic.
     * @param length
     *      The reserved length. Can differ from the length of the produced codes.
     * @param mnemonic
     *      The mnemonic used for assembling.
     */
    public Assembled(boolean unresolved, boolean positionSensitive, List<Token> tokens, long codePoint, byte[] codes,
                     int length, Mnemonic mnemonic) {
        this.unresolved = unresolved;
        this.positionSensitive = positionSensitive;
        this.tokens = Objects.requireNonNull(tokens, "Tokens cannot be null!");
        this.codePoint = codePoint;
        this.codes = codes;
        this.length = length;
        this.mnemonic = Objects.requireNonNull(mnemonic, "Mnemonic cannot be null!");
    }

    public boolean isUnresolved() {
        return unresolved;
    }

    public void setUnresolved(boolean unresolved) {
        this.unresolved = unresolved;
    }

    public boolean isPositionSensitive() {
        return positionSensitive;
    }

    public void setPositionSensitive(boolean positionSensitive) {
        this.positionSensitive = positionSensitive;
    }

    public List<Token> getTokens() {
        return tokens;
    }

    public void setTokens(List<Token> tokens) {
        this.tokens = tokens;
    }

    public long getCodePoint() {
        return codePoint;
    }

    public void setCodePoint(long codePoint) {
        this.codePoint = codePoint;
    }

    public byte[] getCodes() {
        return codes;
    }

    public void setCodes(byte[] codes) {
        if (codes.length < length) {
            this.codes = new byte[length];
            for (int i = 0; i < codes.length; ++i)
                this.codes[i] = codes[i];
        } else {
            this.codes = codes;
            this.length = codes.length;
        }
    }

    public int getLength() {
        return length;
    }

    public void setLength(int length) {
        this.length = length;
    }

    public Mnemonic getMnemonic() {
        return mnemonic;
    }

    public void setMnemonic(Mnemonic mnemonic) {
        this.mnemonic = mnemonic;
    }

    @Override
    public String toString() {
        StringBuilder codesString = new StringBuilder("[");
        for (byte c : codes)
            codesString.append(String.format("%02x", c)+", ");
        codesString.setLength(codesString.length()-2);
        codesString.append("]");
        return this.getClass().getSimpleName()+"["+mnemonic.toString()+", Address:"+String.format("%04x", codePoint)+
                ", Codes:" +codesString+", Length:"+getLength()+", "+Arrays.toString(tokens.toArray())+
                ", Unresolved:"+unresolved+"]";
    }
}
